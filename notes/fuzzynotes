#!/usr/bin/env python
#
# fuzzynotes
#
# A command line interface for managing a notes folder
# using fzf, vim, git, markdown, and YAML front-matter.
#
# When in fzf:
#     enter -> open in vim
#     ctrl-r -> remove file
#     ctrl-p -> print file
#
# If the fzf selection is empty, the query string is used to create a new note
# (in the style of Notational Velocity).

import sys, os, re, yaml, datetime
from subprocess import (Popen, PIPE, CalledProcessError,
                        call, check_call, check_output)

NOTESDIR = os.getenv("NOTESDIR")
if not NOTESDIR:
    sys.exit("fuzzynotes error: NOTESDIR not set")

if not os.path.isdir(os.path.join(NOTESDIR, ".git")):
    sys.exit("fuzzynotes error: no git repo at NOTESDIR")

def relative(dt):
    """Format the given datetime object to human readable relative time."""
    diff = datetime.datetime.now() - dt
    s = int(diff.total_seconds())
    if s <= 1:
        return 'just now'
    elif s < 60:
        return '{} seconds ago'.format(s)
    elif s < 120:
        return '1 minute ago'
    elif s < 3600:
        return '{} minutes ago'.format(s/60)
    elif s < 7200:
        return '1 hour ago'
    elif diff.days == 0:
        return '{} hours ago'.format(s/3600)
    elif diff.days == 1:
        return '1 day ago'
    else:
        return '{} days ago'.format(diff.days)

def generate_data():
    """Yield all notes data gathered from the filesystem and git."""
    # Note data is represented as dicts rather than namedtuples for the sake of
    # YAML serialisation.
    for filename in os.listdir(NOTESDIR):
        if filename.endswith('md'):
            with open(os.path.join(NOTESDIR, filename)) as f:
                cmd = "git log -1 --format='%at' -- '{}'"
                out = check_output(cmd.format(filename), shell=True).strip()
                modified = int(out) # A UNIX timestamp
                metadata = next(yaml.load_all(f))
                yield {"filename": filename,
                       "modified": modified,
                       "description": metadata.get('description', ''),
                       "tags": metadata.get('tags', [])}

def write_to_cache(hash, data):
    """Write the git SHA1 hash of the latest commit and the notes data into a
    YAML cache file."""
    assert os.getcwd() == NOTESDIR
    with open(".cache", "w") as f:
        f.write(yaml.safe_dump({"hash": hash,
                                "data": data}))

def read_from_cache():
    """Return a tuple of the SHA1 hash, and the YAML data."""
    assert os.getcwd() == NOTESDIR
    with open(".cache", "r") as f:
        x = yaml.safe_load(f)
    return x['hash'], x['data']

def get_notes():
    """Attempt to get notes data from cache, otherwise generate it and write to
    the cache, before returning the data."""
    assert os.getcwd() == NOTESDIR
    cache_hash, data = read_from_cache()
    curr_hash = check_output(["git", "rev-parse", "HEAD"]).strip()
    status = check_output(["git", "status", "--porcelain"])
    if cache_hash == curr_hash and status == '':
        # Cache is valid
        return data
    else:
        # Cache is invalid
        data = list(generate_data())
        write_to_cache(curr_hash, data)
        return data

class colours:
    # GOLD    = '\033[38;5;179m'
    DEFAULT = '\033[39m'
    GREEN   = '\033[32m'
    BLUE    = '\033[34m'

SEP  = " "
FNAME = colours.DEFAULT + "{filename}"
MOD  = colours.BLUE + "{modified}"
DESC = colours.DEFAULT + "{description}"
TAGS = colours.GREEN + "{tags}"
FMT = FNAME + ":" + DESC + SEP + MOD + SEP + TAGS + colours.DEFAULT

def format_for_fzf(data):
    """Transform the notes data into a form amenable for filtering in fzf.

    The data is a list of python dicts.
    """
    # Sort by last modified time and turn into readable relative time
    data.sort(key=lambda d: d['modified'], reverse=True)
    for d in data:
        dt = datetime.datetime.fromtimestamp(d['modified'])
        d['modified'] = relative(dt)

    # Left justify modified and description fields based on max length.
    # @ symbols are added to tags to aid with filtering in fzf.
    modlen = max(len(d['modified']) for d in data)
    desclen = max(len(d['description']) for d in data)
    for d in data:
        d['description'] = d['description'].ljust(desclen)
        d['modified'] = d['modified'].ljust(modlen)
        d['tags'] = ", ".join('@'+t for t in d['tags'])

    return '\n'.join(FMT.format(**d) for d in data)

def slugify(s):
    """A very simple function to turn a string into a slug. Used to turn
    descriptions into filenames.
    """
    return re.sub('\W+', '-', s.strip().lower())

def new_note(query):
    if not query:
        sys.exit("fuzzynotes error: no description given")
    slug = slugify(query)
    call(["vim", os.path.join(NOTESDIR, slug)+".md",
          "-c", ":call NoteTemplate('{}')".format(query)])

# We define the following subcommands for the 'fuzzynotes' CLI:
#     show, rename, commit, sync, autosync, run
# They are intended to be used via shell aliases, e.g.
#     alias n='fuzzynotes run'
#     alias nsync='fuzzynotes rename && fuzzynotes sync'
#     alias autosync='fuzzynotes autosync &'

def show(args):
    print(format_for_fzf(get_notes()))

def rename(args):
    """Ensure the filenames of all notes match the yaml description field.

    In case of difference, rename the file with a slugified version of the
    field.
    """
    for filename in os.listdir(NOTESDIR):
        if filename.endswith('md'):
            with open(os.path.join(NOTESDIR, filename)) as f:
                metadata = next(yaml.load_all(f))
                slug = slugify(metadata['description'])+'.md'
                if filename != slug:
                    os.rename(os.path.join(NOTESDIR, filename),
                              os.path.join(NOTESDIR, slug))
                    print("fuzzynotes rename: {} -> {}".format(filename, slug))

def commit(args):
    """Commit all changes in $NOTESDIR with auto generated message."""
    assert os.getcwd() == NOTESDIR
    if check_output(["git", "status", "--porcelain"]):
        NOW = check_output(["date", "+%Y-%m-%d %H:%M:%S %Z"])
        check_call(["git", "add", "--verbose", "--all"])
        check_call(["git", "commit", "-m", "auto: latest updates at {}".format(NOW)])

def sync(args):
    """Synchronise notes git repo with remote.

    1) Commit all changes with auto generated message
    2) Fetch changes from upstream
    3) Rebase (raise error on failure)
    4) Push changes to upstream
    """
    assert os.getcwd() == NOTESDIR
    # Commit all changes with auto-generated messsage
    commit(args)

    # Attempt to fetch and rebase
    check_call(["git", "fetch"])
    try:
        check_call(["git", "rebase", "origin/master"])
    except CalledProcessError:
        sys.exit("fuzzynotes error: rebase failed")

    # Push all changes
    check_call(["git", "push"])

def autosync(args):
    """Launch modd in NOTESDIR to automatically sync on file changes.

    Intended to be run as a background job in the shell, i.e.
        fuzzynotes autosync &
    """
    assert os.getcwd() == NOTESDIR
    # TODO: We might be running modd for another purpose, so using pgrep to
    # check whether it is already running autosync is a bit of a hack.
    try:
        check_call(["pgrep", "modd"])
    except CalledProcessError:
        # pgrep will return code 1 in case of no match, which indicates
        # that modd is not currently running.
        with open(".synclog", "a") as logfile:
            call(["modd"], stdout=logfile)
    else:
        # pgrep returned code 0, indicating a match.
        sys.exit("autosync fail: modd already running?")

def run(args):
    """Run fzf with the given query on the notes folder data.

    enter -> open in vim
    ctrl-r -> remove file
    ctrl-p -> print file

    If the fzf selection is empty, the query string is used to create a new
    note.
    """
    query = ''
    if args.query:
        query = ' '.join(args.query)

    notes = format_for_fzf(get_notes())

    opts = [
        "fzf -q '{}'".format(query),
        "--exact --ansi --print-query",
        "-d ':' --with-nth=2..",
        "--expect=enter,ctrl-r,ctrl-p",
        "--preview=\"cat $NOTESDIR/{1}\"",
        "--preview-window=up:50%"
    ]

    cmd = " ".join(opts)
    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE)
    out, err = p.communicate(notes.encode())

    # out will be empty if fzf is exits early (e.g. pressing ESC)
    if out:
        lines = out.decode().split('\n')
        query, key, data = lines[0], lines[1], lines[2]

        if not data and key == "enter":
            # Our fzf selection was empty
            new_note(query)

        else:
            # Our fzf selection was not empty
            filename, _ = data.split(":")
            if key == "ctrl-r":
                check_call(["rm", "-i", os.path.join(NOTESDIR, filename)])
            elif key == "ctrl-p":
                check_call(["cat", os.path.join(NOTESDIR, filename)])
            else:
                call(["vim", os.path.join(NOTESDIR, filename)])

if __name__ == "__main__":
    import argparse

    WORKING_DIR = os.getenv("PWD")
    os.chdir(NOTESDIR)

    parser = argparse.ArgumentParser(description='Manage a notes folder')
    subparsers = parser.add_subparsers()

    run_parser = subparsers.add_parser('run')
    run_parser.add_argument('query', nargs='*')
    run_parser.set_defaults(func=run)

    subparsers.add_parser('show').set_defaults(func=show)
    subparsers.add_parser('rename').set_defaults(func=rename)
    subparsers.add_parser('commit').set_defaults(func=commit)
    subparsers.add_parser('sync').set_defaults(func=sync)
    subparsers.add_parser('autosync').set_defaults(func=autosync)

    args = parser.parse_args()
    args.func(args)

    os.chdir(WORKING_DIR)
