#!/usr/bin/env python
#
# fuzzynotes
#
# A command line interface for managing a notes folder
# using fzf, vim, git, markdown, and YAML front-matter.
#
# When in fzf:
#     enter -> open in vim
#     ctrl-r -> remove file
#     ctrl-p -> print file
#
# If the fzf selection is empty, the query string is used to create a new note
# (in the style of Notational Velocity).

import sys, os, re, yaml, datetime
from collections import namedtuple
from subprocess import (Popen, PIPE, CalledProcessError,
                        call, check_call, check_output)

NOTESDIR = os.getenv("NOTESDIR")
if not NOTESDIR:
    sys.exit("fuzzynotes error: NOTESDIR not set")

if not os.path.isdir(os.path.join(NOTESDIR, ".git")):
    sys.exit("fuzzynotes error: no git repo at NOTESDIR")

def relative(dt):
    """Format the given datetime object to human readable relative time."""
    diff = datetime.datetime.now() - dt
    s = int(diff.total_seconds())
    if s <= 1:
        return 'just now'
    elif s < 60:
        return '{} seconds ago'.format(s)
    elif s < 120:
        return '1 minute ago'
    elif s < 3600:
        return '{} minutes ago'.format(s/60)
    elif s < 7200:
        return '1 hour ago'
    elif diff.days == 0:
        return '{} hours ago'.format(s/3600)
    elif diff.days == 1:
        return '1 day ago'
    else:
        return '{} days ago'.format(diff.days)

Note = namedtuple("Note", ["filename", "modified", "description", "tags"])

def all_notes():
    """Yield all Notes."""
    for filename in os.listdir(NOTESDIR):
        if filename.endswith('md'):
            with open(os.path.join(NOTESDIR, filename)) as f:
                cmd = "git log -1 --format='%at' -- '{}'"
                out = check_output(cmd.format(filename), shell=True).strip()
                modified = datetime.datetime.fromtimestamp(int(out))
                metadata = next(yaml.load_all(f))
                yield Note(filename,
                           modified,
                           metadata.get('description', ''),
                           metadata.get('tags', []))

class colours:
    DEFAULT = '\033[39m'
    GREEN   = '\033[32m'
    BLUE    = '\033[34m'
    GOLD    = '\033[38;5;179m'

SEP  = colours.GOLD + " "
FNAME = colours.DEFAULT + "{filename}"
MOD  = colours.BLUE + "{modified}"
DESC = colours.DEFAULT + "{description}"
TAGS = colours.GREEN + "{tags}"

# e.g. "example.md:My First Description | 2 days ago | @tag1, @tag2"
FMT = FNAME + ":" + DESC + SEP + MOD + SEP + TAGS + colours.DEFAULT

def format(notes):
    """Transform a list of Note objects into a newline separated string format amenable to
    filtering using fzf.

    Each tag is prefixed with an @ symbol to aid with filtering.
    """
    filenames = [note.filename for note in notes]
    mods = [relative(note.modified) for note in notes]
    descriptions = [note.description for note in notes]
    tags = [", ".join('@'+t for t in note.tags) for note in notes]

    # Left justify mods and descriptions based on max length.
    modlen = max(len(x) for x in mods)
    desclen = max(len(x) for x in descriptions)
    mods = [mod.ljust(modlen) for mod in mods]
    descriptions = [description.ljust(desclen) for description in descriptions]

    # Recombine fields.
    notes = [Note(*fields) for fields in zip(filenames, mods, descriptions, tags)]
    return '\n'.join(FMT.format(filename=note.filename,
                                modified=note.modified,
                                description=note.description,
                                tags=note.tags)
                     for note in notes)

def slugify(s):
    """A very simple function to turn a string into a slug. Used to turn
    descriptions into filenames.
    """
    return re.sub('\W+', '-', s.strip().lower())

def new_note(query):
    if not query:
        sys.exit("fuzzynotes error: no description given")
    slug = slugify(query)
    call(["vim", os.path.join(NOTESDIR, slug)+".md",
          "-c", ":call NoteTemplate('{}')".format(query)])

# We define the following subcommands for the 'fuzzynotes' CLI:
#     show, rename, commit, sync, autosync, run
# They are intended to be used via shell aliases, e.g.
#     alias n='fuzzynotes run'
#     alias nsync='fuzzynotes rename && fuzzynotes sync'
#     alias autosync='fuzzynotes autosync &'

def show(args):
    print(format(sorted(list(all_notes()),
                        key=lambda x: x.modified,
                        reverse=True)))

def rename(args):
    """Ensure the filenames of all notes match the yaml description field.

    In case of difference, rename the file with a slugified version of the
    field.
    """
    for filename in os.listdir(NOTESDIR):
        if filename.endswith('md'):
            with open(os.path.join(NOTESDIR, filename)) as f:
                metadata = next(yaml.load_all(f))
                slug = slugify(metadata['description'])+'.md'
                if filename != slug:
                    os.rename(os.path.join(NOTESDIR, filename),
                              os.path.join(NOTESDIR, slug))
                    print("fuzzynotes rename: {} -> {}".format(filename, slug))

def commit(args):
    """Commit all changes in $NOTESDIR with auto generated message."""
    assert os.getcwd() == NOTESDIR

    # Commit all changes with auto-generated messsage
    if check_output(["git", "status", "--porcelain"]):
        NOW = check_output(["date", "+%Y-%m-%d %H:%M:%S %Z"])
        check_call(["git", "add", "--verbose", "--all"])
        check_call(["git", "commit", "-m", "auto: latest updates at {}".format(NOW)])

def sync(args):
    """Synchronise notes git repo with remote.

    1) Commit all changes with auto generated message
    2) Fetch changes from upstream
    3) Rebase (raise error on failure)
    4) Push changes to upstream
    """
    assert os.getcwd() == NOTESDIR

    # Commit all changes with auto-generated messsage
    commit(args)

    # Attempt to fetch and rebase
    check_call(["git", "fetch"])
    try:
        check_call(["git", "rebase", "origin/master"])
    except CalledProcessError:
        sys.exit("fuzzynotes error: rebase failed")

    # Push all changes
    check_call(["git", "push"])

def autosync(args):
    """Launch modd in NOTESDIR to automatically sync on file changes.

    Intended to be run as a background job in the shell, i.e.
        fuzzynotes autosync &
    """
    assert os.getcwd() == NOTESDIR

    # TODO: We might be running modd for another purpose, so using pgrep to
    # check whether it is already running autosync is a bit of a hack.
    try:
        check_call(["pgrep", "modd"])
    except CalledProcessError:
        # pgrep will return code 1 in case of no match, which indicates
        # that modd is not currently running.
        with open(".synclog", "a") as logfile:
            call(["modd"], stdout=logfile)
    else:
        # pgrep returned code 0, indicating a match.
        sys.exit("autosync fail: modd already running?")

def run(args):
    """Run fzf with the given query on the notes folder data.

    enter -> open in vim
    ctrl-r -> remove file
    ctrl-p -> print file

    If the fzf selection is empty, the query string is used to create a new
    note.
    """
    query = ''
    if args.query:
        query = ' '.join(args.query)

    notes = format(sorted(all_notes(),
                          key=lambda x: x.modified,
                          reverse=True))
    opts = [
        "fzf -q '{}'".format(query),
        "--exact --ansi --print-query",
        "-d ':' --with-nth=2..",
        "--expect=enter,ctrl-r,ctrl-p",
        "--preview=\"cat $NOTESDIR/{1}\"",
        "--preview-window=up:50%"
    ]

    cmd = " ".join(opts)
    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE)
    out, err = p.communicate(notes.encode())

    # out will be empty if fzf is exits early (e.g. pressing ESC)
    if out:
        lines = out.decode().split('\n')
        query, key, data = lines[0], lines[1], lines[2]

        if not data and key == "enter":
            # Our fzf selection was empty
            new_note(query)

        else:
            # Our fzf selection was not empty
            filename, _ = data.split(":")
            if key == "ctrl-r":
                check_call(["rm", "-i", os.path.join(NOTESDIR, filename)])
            elif key == "ctrl-p":
                check_call(["cat", os.path.join(NOTESDIR, filename)])
            else:
                call(["vim", os.path.join(NOTESDIR, filename)])

if __name__ == "__main__":
    import argparse

    WORKING_DIR = os.getenv("PWD")
    os.chdir(NOTESDIR)

    parser = argparse.ArgumentParser(description='Manage a notes folder')
    subparsers = parser.add_subparsers()

    run_parser = subparsers.add_parser('run')
    run_parser.add_argument('query', nargs='*')
    run_parser.set_defaults(func=run)

    subparsers.add_parser('show').set_defaults(func=show)
    subparsers.add_parser('rename').set_defaults(func=rename)
    subparsers.add_parser('commit').set_defaults(func=commit)
    subparsers.add_parser('sync').set_defaults(func=sync)
    subparsers.add_parser('autosync').set_defaults(func=autosync)

    args = parser.parse_args()
    args.func(args)

    os.chdir(WORKING_DIR)
