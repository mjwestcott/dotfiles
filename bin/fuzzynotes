#!/usr/bin/env python
#
# fuzzynotes
#
# A command line interface for managing a notes folder
# using fzf, vim, git, markdown, and YAML front-matter.
#
# When in fzf:
#     enter -> open in vim
#     ctrl-r -> remove file
#     ctrl-p -> print file
#
# If the fzf selection is empty, the query string is used to create a new note
# (in the style of Notational Velocity).

import sys, os, re, yaml
from collections import namedtuple
from subprocess import (Popen, PIPE, CalledProcessError,
                        call, check_call, check_output)

NOTESDIR = os.getenv("NOTESDIR")
if not NOTESDIR:
    sys.exit("fuzzynotes error: NOTESDIR not set")

Note = namedtuple("Note", ["modified", "filename", "description", "tags"])

def all_notes():
    """Yield all Notes."""
    for filename in os.listdir(NOTESDIR):
        if filename.endswith('md'):
            with open(os.path.join(NOTESDIR, filename)) as f:
                cmd = "git log -1 --format='%at' -- '{}'"
                modified = check_output(cmd.format(filename), shell=True).strip()
                metadata = next(yaml.load_all(f))
                yield Note(modified,
                           filename,
                           metadata.get('description', ''),
                           metadata.get('tags', []))

class colours:
    DEFAULT = '\033[39m'
    GREEN   = '\033[32m'
    BLUE    = '\033[34m'
    GOLD    = '\033[38;5;179m'

# The format string will be used to produce string such as:
#     "1477483226|example.md|My First Description ~ @tag1, @tag2"
FMT = "{modified}|{filename}|{c1}{description}{c2}{separator}{c3}{tags}{c4}"

def format(note, sep= " :: "):
    """Transform a Note object into a pretty string format amenable to
    filtering using fzf.
    """
    # Each tag is prefixed with an @ symbol to aid with filtering.
    return FMT.format(c1=colours.DEFAULT,
                      c2=colours.GOLD,
                      c3=colours.GREEN,
                      c4=colours.DEFAULT,
                      modified=note.modified,
                      filename=note.filename,
                      description=note.description,
                      separator=sep,
                      tags=", ".join('@'+t for t in note.tags))

def format_many(notes):
    """Transform a list of Note objects to a newline separated string of
    formatted notes.
    """
    return '\n'.join(format(note) for note in notes)

def slugify(s):
    """A very simple function to turn a string into a slug. Used to turn
    descriptions into filenames.
    """
    return re.sub('\W+', '-', s.strip().lower())

def new_note(query):
    if not query:
        sys.exit("fuzzynotes error: no description given")
    slug = slugify(query)
    call(["vim", os.path.join(NOTESDIR, slug)+".md",
          "-c", ":call NoteTemplate('{}')".format(query)])

# We define four subcommands for the 'fuzzynotes' CLI:
#     show, rename, sync, run
# They are intended to be used via shell aliases, e.g.
#     alias n='fuzzynotes run'
#     alias nsync='fuzzynotes rename && fuzzynotes sync'

def show(args):
    print(format_many(sorted(list(all_notes()),
                             key=lambda x: x.modified,
                             reverse=True)))

def rename(args):
    """Ensure the filenames of all notes match the yaml description field.

    In case of difference, rename the file with a slugified version of the
    field.
    """
    for filename in os.listdir(NOTESDIR):
        if filename.endswith('md'):
            with open(os.path.join(NOTESDIR, filename)) as f:
                metadata = next(yaml.load_all(f))
                slug = slugify(metadata['description'])+'.md'
                if filename != slug:
                    os.rename(os.path.join(NOTESDIR, filename),
                              os.path.join(NOTESDIR, slug))
                    print("fuzzynotes rename: {} -> {}".format(filename, slug))

def sync(args):
    """Synchronise notes git repo with remote.

    1) Commit all changes with auto generated message
    2) Fetch changes from upstream
    3) Rebase (raise error on failure)
    4) Push changes to upstream
    """
    if not os.path.isdir(os.path.join(NOTESDIR, ".git")):
        raise ValueError("fuzzynotes: no git repo at $NOTESDIR")

    os.chdir(NOTESDIR)
    print(colours.GOLD + "=== Start Notes Sync ===" + colours.DEFAULT)

    # Commit all changes with auto-generated messsage
    if check_output(["git", "status", "--porcelain"]):
        NOW = check_output(["date", "+%Y-%m-%d %H:%M:%S %Z"])
        check_call(["git", "add", "--all"])
        check_call(["git", "commit", "-m", "auto: latest updates at {}".format(NOW)])

    # Attempt to fetch and rebase
    check_call(["git", "fetch"])
    try:
        check_call(["git", "rebase", "origin/master"])
    except CalledProcessError:
        sys.exit("fuzzynotes error: rebase failed")

    # Push all changes
    check_call(["git", "push"])

    print(colours.GOLD + "=== End Notes Sync ===" + colours.DEFAULT)
    os.chdir(os.getenv("OLDPWD"))

def run(args):
    """Run fzf with the given query on the notes folder data.

    enter -> open in vim
    ctrl-r -> remove file
    ctrl-p -> print file

    If the fzf selection is empty, the query string is used to create a new
    note.
    """
    query = ''
    if args.query:
        query = ' '.join(args.query)

    notes = format_many(sorted(all_notes(),
                               key=lambda x: x.modified,
                               reverse=True))
    opts = [
        "fzf -q '{}'".format(query),
        "--exact --ansi --print-query",
        "-d '\|' --with-nth=3..",
        "--expect=enter,ctrl-r,ctrl-p",
        "--preview=\"cat $NOTESDIR/{2}\""
    ]

    # Choose preview size and location based on tmux pane width
    out = Popen("tmux display-message -p '#{pane_width}'",
                shell=True, stdout=PIPE, stderr=PIPE).stdout.read()
    if out != '' and int(out) < 160:
        opts.append("--preview-window=up:50%")

    cmd = " ".join(opts)
    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE)
    out, err = p.communicate(notes.encode())

    # out will be empty if fzf is exits early (e.g. pressing ESC)
    if out:
        lines = out.decode().split('\n')
        query, key, data = lines[0], lines[1], lines[2]

        if not data and key == "enter":
            # Our fzf selection was empty
            new_note(query)

        else:
            # Our fzf selection was not empty
            _, filename, _ = data.split("|")
            if key == "ctrl-r":
                check_call(["rm", "-i", os.path.join(NOTESDIR, filename)])
            elif key == "ctrl-p":
                check_call(["cat", os.path.join(NOTESDIR, filename)])
            else:
                call(["vim", os.path.join(NOTESDIR, filename)])

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='Manage a notes folder')
    subparsers = parser.add_subparsers()

    run_parser = subparsers.add_parser('run')
    run_parser.add_argument('query', nargs='*')
    run_parser.set_defaults(func=run)

    subparsers.add_parser('show').set_defaults(func=show)
    subparsers.add_parser('rename').set_defaults(func=rename)
    subparsers.add_parser('sync').set_defaults(func=sync)

    args = parser.parse_args()
    args.func(args)
